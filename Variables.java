/**
 * creates the variables which are used to create the code and
 * includes some methods related to creating variables and
 * initializes the project by reading file
 * @author Nuri Basar, Student ID: 2021400129
 *  @since date: 02.05.2023
 */
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;

public class Variables {
    public static ArrayList<ArrayList<String>> inputMatrix = new ArrayList<>(); // stores the matrix given in the file. There will be some changes on it.
    public static ArrayList<ArrayList<String>> initialInputMatrix = new ArrayList<>(); //stores the matrix given in the file and won't change
    public static int matrixRow; // the number of the row of the matrix
    public static int matrixColumn; // the number of the column of the matrix
    public static String[] alphabet= new String[26]; // stores  all letters in the alphabet. it is generated by creatingAlphabet method
    public static ArrayList<String> allPossibilitiesForCoordinate = new ArrayList<>(); // stores all possible words for the coordinate naming
    public static ArrayList<String> allPossibilitiesForLake = new ArrayList<>(); // stores all possible words for puddle naming
    public static ArrayList<String> copiedAllPossibilitiesForLake = new ArrayList<>(); // to control which words are used
    public static ArrayList<String> additionalRow = new ArrayList<>(); // stores words which need to be printed for coordinate naming
    public static ArrayList<String> additionalColumn = new ArrayList<>(); // stores numbers which need to be printed for coordinate naming
    public static ArrayList<ArrayList<Integer>> allCoordinates = new ArrayList<>(); // stores all coordinate in the matrix to mak code easier
    public static ArrayList<ArrayList<Integer>> coordinatesCanBePuddle = new ArrayList<>(); // all coordinates except for borders because borders cannot be puddle
    public static ArrayList<ArrayList<Integer>> coordinatesCannotBePuddle = new ArrayList<>(); // stores borders coordinate
    public static ArrayList<ArrayList<Integer>> oneStepInnerCoordinates = new ArrayList<>();  //the nearest coordinates to borders to control the limiting value there
    public static ArrayList<Integer> oneStepInnerCoordinatesMinValues = new ArrayList<>(); //the limiting values for the previous coordinates
    public static ArrayList<Integer> minValues =new ArrayList<>(); // stores the min Values of puddles to calculate volume
    /**
     * reads file and assign values to matrixRow, matrixColumn and inputMatrix
     * * @throws FileNotFoundException
     */
    public static void readingFileAndCreatingVariables() throws FileNotFoundException {
        File file = new File("input3.txt"); // opes the file
        Scanner inputFile= new Scanner(file);
        String firstLine = inputFile.nextLine().trim(); // takes the first line which contains the row and column numbers
        String[] rowAndColumn = firstLine.split(" "); // separates the row and the column as an array
        // assigns the values to the related variables
        matrixRow = Integer.parseInt(rowAndColumn[1]);
        matrixColumn =  Integer.parseInt(rowAndColumn[0]);
        //reading the file to take the matrix
        for (int i=0; i<matrixRow ; i++){
            ArrayList<String> tempArray = new ArrayList<>(); // stores the row temporarily
            String row = inputFile.nextLine().trim(); //reading a line
            String[] rowArray = row.split(" "); // separating columns values between each others
            for (String height: rowArray){ // taking columns separately
                tempArray.add(height);
            }
            inputMatrix.add(tempArray);
        }
        initialInputMatrix = cloneArray(inputMatrix);
    }
    /**
     * creates alphabet as an array
     */
    public static void creatingAlphabet(){
        char index = 'a';
        for (int i=0; i<alphabet.length; i++){
            alphabet[i] = String.valueOf((char) (index+i));
        }
    }
    /**
     *  finds all possible words for puddle and coordinate naming
     */
    public static void findingPossibilities(){
        creatingAlphabet();
        for(String letter: alphabet){
            allPossibilitiesForCoordinate.add(letter);
            if (letter.equals("i"))
                allPossibilitiesForLake.add("I");
            else
                allPossibilitiesForLake.add(letter.toUpperCase());
        }
        for(String firstLetter: alphabet){
            for(String secondLetter: alphabet){
                String concatenation = firstLetter+secondLetter;
                allPossibilitiesForCoordinate.add(concatenation);
                if(firstLetter.equals("i")){
                    if (secondLetter.equals("i"))
                        allPossibilitiesForLake.add("II");
                    else
                        allPossibilitiesForLake.add("I"+secondLetter.toUpperCase());
                }else{
                    if(secondLetter.equals("i"))
                        allPossibilitiesForLake.add(firstLetter.toUpperCase() +"I");
                    else
                        allPossibilitiesForLake.add(concatenation.toUpperCase());
                }
            }

        }
        copiedAllPossibilitiesForLake = new ArrayList<>(allPossibilitiesForLake);
        determiningAdditionals();
        determiningCoordinates();
    }
    /**
     * finds the numbers and words printed on the console
     */
    public static void determiningAdditionals(){
        for(int i=0; i<matrixColumn; i++){
            String word=allPossibilitiesForCoordinate.get(i);
            additionalRow.add(word);
        }
        for (int j=0; j<=matrixRow; j++){
            if (j==matrixRow){
                additionalColumn.add(" ");
                break;
            }
            additionalColumn.add(j+"");
        }

    }

    /**
     * finds the coordinates to assign the variables such as allCoordinates
     */
    public static void determiningCoordinates(){
        for (int i=0; i<matrixRow ; i++){
            for (int j=0; j<matrixColumn ; j++) {
                ArrayList<Integer> tempCoordinate = new ArrayList<>();
                tempCoordinate.add(i);
                tempCoordinate.add(j);
                if (i < matrixRow - 1 && i > 0 && j < matrixColumn - 1 && j > 0){
                    coordinatesCanBePuddle.add(tempCoordinate);
                    if(i==matrixRow-2 || i==1 || j==matrixColumn-2 || j==1){
                        oneStepInnerCoordinates.add(tempCoordinate);
                    }
                }else
                    coordinatesCannotBePuddle.add(tempCoordinate);
                allCoordinates.add(tempCoordinate);
            }
        }
    }

    /**
     * finds the borders values to assign oneStepInnerCoordinateMinValues
     */
    public static void determiningBordersValue() {
        for (ArrayList<Integer> coordinate : oneStepInnerCoordinates) {
            ArrayList<Integer> borderValues = new ArrayList<>();
            int x = coordinate.get(0);
            int y = coordinate.get(1);
            if (x == 1) {
                for (int i = y - 1; i <= y + 1; i++) {
                    if (!borderValues.contains(Integer.parseInt(inputMatrix.get(0).get(i))))
                        borderValues.add(Integer.parseInt(inputMatrix.get(0).get(i)));
                }
                if (y == 1 || y == Variables.matrixColumn - 2) {
                    for (int i = x; i <= x + 1; i++) {
                        if (y == 1)
                            if (!borderValues.contains(Integer.parseInt(inputMatrix.get(i).get(0))))
                                borderValues.add(Integer.parseInt(inputMatrix.get(i).get(0)));
                        if (y == Variables.matrixColumn - 2)
                            if (!borderValues.contains(Integer.parseInt(inputMatrix.get(0).get(y + 1))))
                                borderValues.add(Integer.parseInt(inputMatrix.get(0).get(y + 1)));
                    }
                }
            }
            if (x == Variables.matrixRow - 2) {
                for (int i = y - 1; i <= y + 1; i++) {
                    if (!borderValues.contains(Integer.parseInt(inputMatrix.get(x + 1).get(i))))
                        borderValues.add(Integer.parseInt(inputMatrix.get(x + 1).get(i)));
                }
                if (y == 1 || y == Variables.matrixColumn - 2) {
                    for (int i = x - 1; i <= x; i++) {
                        if (y == 1)
                            if (!borderValues.contains(Integer.parseInt(inputMatrix.get(i).get(0))))
                                borderValues.add(Integer.parseInt(inputMatrix.get(i).get(0)));
                        if (y == Variables.matrixColumn - 2)
                            if (!borderValues.contains(Integer.parseInt(inputMatrix.get(i).get(y + 1))))
                                borderValues.add(Integer.parseInt(inputMatrix.get(i).get(y + 1)));
                    }
                }
            }
            if (!(x == 1)) {
               if (!(x == Variables.matrixRow - 2)) {
                    if (y == 1 || y == Variables.matrixColumn - 2) {
                        for (int i = x - 1; i <= x + 1; i++) {
                            if (y == 1)
                                if (!borderValues.contains(Integer.parseInt(inputMatrix.get(i).get(0))))
                                    borderValues.add(Integer.parseInt(inputMatrix.get(i).get(0)));
                            if (y == Variables.matrixColumn - 2)
                                if (!borderValues.contains(Integer.parseInt(inputMatrix.get(i).get(y + 1))))
                                    borderValues.add(Integer.parseInt(inputMatrix.get(i).get(y + 1)));
                        }
                    }
               }
            }
            int minValue = borderValues.get(0);
            for (Integer val : borderValues) {
                if (val < minValue)
                    minValue = val;
            }
            oneStepInnerCoordinatesMinValues.add(minValue);
        }
    }

    /**
     * clones the input array without assigning same reference number.
     * @param mainArray is an array containing an array which contains value whose type is string
     * @return clone array
     */
    public static ArrayList<ArrayList<String>> cloneArray(ArrayList<ArrayList<String>> mainArray){
        ArrayList<ArrayList<String>> copiedArray = new ArrayList<>(); // temp array to store string values
        for (ArrayList<String> insideMainArray: mainArray){
            ArrayList<String> copyInside = new ArrayList<>();
            for(String element: insideMainArray){
                copyInside.add(element);
            }
            copiedArray.add(copyInside);
        }
        return copiedArray;
    }

    /**
     * clones the input array without assigning same reference number.
     * @param mainArray is an array containing an array which contains value whose type is ınteger
     * @return clone array
     */
    public static ArrayList<ArrayList<Integer>> cloneArrayInteger(ArrayList<ArrayList<Integer>> mainArray){
        ArrayList<ArrayList<Integer>> copiedArray = new ArrayList<>(); // temp array to store integer values
        for (ArrayList<Integer> insideMainArray: mainArray){
            ArrayList<Integer> copyInside = new ArrayList<>();
            for(Integer element: insideMainArray){
                copyInside.add(element);
            }
            copiedArray.add(copyInside);
        }
        return copiedArray;
    }
}
